def batchSize = 10

pipeline {
    agent none
    //triggers {
    //    cron('30 23 * * *') //run at 23:31:00
    //}
    options {
        timestamps()
    }
    parameters {
        gitParameter branchFilter: 'origin/(.*)', defaultValue: 'dev', name: 'sha1', type: 'PT_BRANCH', quickFilterEnabled: true
        booleanParam name: 'FAKE_BINARIES', defaultValue: false, description: 'If enabled, generate fake binaries instead of Azure pipelines (for fast testing)'
        booleanParam name: 'DRYRUN', defaultValue: true, description: 'If enabled, will NOT publish pre-release artifacts to Github and Dockerhub.'
        booleanParam name: 'TEST_WEB', defaultValue: false, description: 'If enabled, will execute web tests.'
        booleanParam name: 'TEST_FUNC', defaultValue: true, description: 'If enabled, will execute func tests.'
        booleanParam name: 'TEST_UPGRADE', defaultValue: true, description: 'If enabled, will execute upgrade tests.'
        booleanParam name: 'DOCKER_EXTENSION', defaultValue: true, description: 'If enabled, deploy Docker Image for Docker Extension.'
    }

    stages {
        stage('Clone repository') {
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker'
                }
            }
            steps {
                script {
                    if (env.ghprbPullLink) {
                        env.COMMIT = env.ghprbSourceBranch
                    } else {
                        env.COMMIT = params.sha1
                    }
                    sh 'docker ps -a --filter name=localnode-* -aq | xargs docker rm -f || true'
                }
                echo "${COMMIT}"
                git branch: "${COMMIT}", url: 'https://github.com/gosh-sh/gosh.git'
                checkout scm
                script {
                    env.APP_VERSION = sh script: "cat version.json | jq .version | tr -d '\"\n'", returnStdout: true
                    currentBuild.displayName = "${BUILD_NUMBER}_${COMMIT}_${APP_VERSION}"
                }

                echo "JOB_NAME=${JOB_NAME}"
                echo "DRYRUN=${DRYRUN}"
                echo "FAKE_BINARIES=${FAKE_BINARIES}"
            }
        }
        stage('Prepare workspace') {
            agent {
                node {
                    label 'jenkins-main'
                }
            }
            steps {
                script {
                    [
                        'linux-amd64',
                        'linux-arm64',
                        'darwin-amd64',
                        'darwin-arm64',
                        'windows-amd64',
                    ].each { target ->
                        sh "rm -rf ${target}"
                        sh "mkdir -p ${target}"
                    }
                }
            }
        }
        stage('Build: Dispatcher') {
            agent {
                node {
                    label 'jenkins-main'
                }
            }
            steps {
                buildDispatcher()
            }
        }
        stage('Build: Git Helper') {
            agent {
                node {
                    label 'jenkins-main'
                }
            }
            steps {
                script {
                    def stages = [
                        'v1_x/v1.0.0',
                        'v2_x/v2.0.0',
                        'v3_x/v3.0.0',
                        'v4_x/v4.0.0',
                        'v5_x/v5.0.0',
                        'v5_x/v5.1.0',
                        'v6_x/v6.0.0',
                        'v6_x/v6.1.0',
                    ].collectEntries { path -> [path, { -> buildRemoteGosh path }] }
                    stages.failFast = true
                    parallel stages
                }
            }
        }

        stage('Build: Prepare archives') {
            agent {
                node {
                    label 'jenkins-main'
                }
            }
            steps {
                archiveAzureArtifacts()
            }
        }

        stage('Tests: Func') {
            when { expression { return params.TEST_FUNC } }
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker --network host -v /root/jenkins-main/workspace:/tmp --add-host localnode:127.0.0.1'
                }
            }
            steps {
                script {
                    sh 'rm -rf tests_workspace_*'
                    def basePort = 9000
                    def files = getTestFiles('tests').toList()
                    // def versions = ["v4_x", "v5_x/v5.0.0", "v5_x/v5.1.0", "v6_x/v6.0.0"]
                    def versions = ['v6_x/v6.1.0']
                    def batches = []
                    for (int i = 0; i < files.size(); i += batchSize) {
                        def end = Math.min(i + batchSize, files.size())
                        batches.add(new ArrayList(files.subList(i, end)))  // <-- Modified
                    }

                    for (int j = 0; j < batches.size(); j++) {
                        def batch = batches[j]
                        for (version in versions) {
                            sh "rm -rf ${version}_workspace_*"
                            deployVersion(version, batch, basePort + (j * batchSize))
                        }

                        // runFunctionalTests(batch, basePort + (j * batchSize), "Func v4", "v4_x")
                        // runFunctionalTests(batch, basePort + (j * batchSize), "Func v5.0", "v5_x/v5.0.0")
                        // runFunctionalTests(batch, basePort + (j * batchSize), "Func v5.1", "v5_x/v5.1.0")
                        runFunctionalTests(batch, basePort + (j * batchSize), 'Func v6.1', 'v6_x/v6.1.0')
                        sh 'docker ps -a --filter name=localnode-* -aq | grep -v "$(docker ps -a --filter name=localnode-9000 -q)" | xargs docker rm -f'
                    }
                }
            }
        }

        stage('Tests: Upgrade') {
            when { expression { return params.TEST_UPGRADE } }
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker --network host -v /root/jenkins-main/workspace:/tmp --add-host localnode:127.0.0.1'
                }
            }
            steps {
                script {
                    sh 'rm -rf tests_workspace_*'
                    def basePort = 9000
                    def versions = ['v5_x/v5.1.0', 'v6_x/v6.0.0', 'v6_x/v6.1.0']

                    def upgradeFiles = getTestFiles('tests/upgrade_tests').toList()
                    def upgradeBatches = []
                    for (int i = 0; i < upgradeFiles.size(); i += batchSize) {
                        def end = Math.min(i + batchSize, upgradeFiles.size())
                        upgradeBatches.add(new ArrayList(upgradeFiles.subList(i, end)))  // <-- Modified
                    }

                    for (int j = 0; j < upgradeBatches.size(); j++) {
                        def batch = upgradeBatches[j]

                        for (version in versions) {
                            sh "rm -rf ${version}_workspace_*"
                            deployVersion(version, batch, basePort + (j * batchSize))
                        }

                        runUpgradeTests(batch, basePort + (j * batchSize), 'v5_x/v5.1.0', 'v6_x/v6.1.0')
                        runUpgradeTests(batch, basePort + (j * batchSize), 'v6_x/v6.0.0', 'v6_x/v6.1.0')
                        // runUpgradeTests(batch, basePort + (j * batchSize), "v4_x", "v5_x/v5.1.0")
                        // runUpgradeTests(batch, basePort + (j * batchSize), "v5_x/v5.0.0", "v5_x/v5.1.0")
                        // runUpgradeTests(batch, basePort + (j * batchSize), "v3_x", "v4_x")
                        sh 'docker ps -a --filter name=localnode-* -aq | grep -v "$(docker ps -a --filter name=localnode-9000 -q)" | xargs docker rm -f'
                    }

                    env.REACT_APP_GOSH_ROOTADDR = sh script: "cat v1_x_workspace_0/contracts/gosh/VersionController.addr | tr -d '\n'", returnStdout: true
                    env.REACT_APP_GOSH = sh script: "cat v1_x_workspace_0/contracts/gosh/SystemContract.addr | tr -d '\n'", returnStdout: true
                }
            }
        }

        stage('Web: deploy') {
            when { expression { return params.TEST_WEB } }
            agent {
                node {
                    label 'jenkins-main'
                }
            }
            steps {
                deployWeb()
            }
        }

        stage('Tests: Web') {
            when { expression { return params.TEST_WEB } }
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker --network host --add-host localnode:127.0.0.1'
                }
            }
            steps {
                testWeb()
            }
            post {
                failure {
                    archiveArtifacts artifacts: 'monitoring/gosh-mon/test-errors/*.log'
                    archiveArtifacts artifacts: 'monitoring/gosh-mon/test-errors/*.png'
                }
            }
        }

        stage('Prerelease: Git Helper - bin') {
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker -v /root/jenkins-main/workspace:/tmp'
                }
            }
            steps {
                prereleaseBinaries()
            }
        }

        stage('Prerelease: push rc Docker Extension image') {
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker'
                }
            }
            steps {
                retry(3) {
                    prereleaseDockerExtension()
                }
            }
        }
    }
    post {
        always {
            node('jenkins-main') {
                cleanWs()
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////FUNCTIONS//////////////////////////////////

// BUILD
def buildDispatcher() {
    script {
        sh 'pwd'
        if (params.FAKE_BINARIES) {
            [
                'linux-amd64',
                'linux-arm64',
                'darwin-amd64',
                'darwin-arm64',
                'windows-amd64'
            ].each { target -> sh "touch ${target}/git-remote-gosh" }
            return true
        }

        String PIPELINE_2_ID
        dir('gosh-dispatcher') {
            String PIPELINE_2_STATUS = ''

            if (params.DRYRUN) {
                PIPELINE_2_ID = sh(
                    script: "az pipelines build queue --definition-id 2 --branch ${COMMIT} --project gosh --variables DRYRUN=true | jq -r .id",
                    returnStdout: true,
                ).trim()
            } else {
                PIPELINE_2_ID = sh(
                    script: "az pipelines build queue --definition-id 2 --branch ${COMMIT} --project gosh | jq -r .id",
                    returnStdout: true,
                ).trim()
            }

            timeout(time: 1, unit: 'HOURS') {
                while (PIPELINE_2_STATUS != 'completed') {
                    sleep time: 60, unit: 'SECONDS'
                    PIPELINE_2_STATUS = sh(
                        script: "az pipelines build show --project gosh --id ${PIPELINE_2_ID} | jq -r .status",
                        returnStdout: true,
                    ).trim()
                    println "$PIPELINE_2_STATUS"
                }
            }
        }

        retry(3) {
            def targets = params.DRYRUN ? ['linux-amd64'] : [
                'linux-amd64',
                'linux-arm64',
                'darwin-amd64',
                'darwin-arm64',
                'windows-amd64'
            ]

            targets.each { target ->
                sh "az pipelines runs artifact download --project gosh --artifact-name ${target} --run-id ${PIPELINE_2_ID} --path ${target}"
                sleep 2
            }
        }
    }
}

def buildRemoteGosh(String versionPath) {
    script {
        sh 'pwd'
        String version = versionPath.split('/')[-1].replace('.', '_')
        if (params.FAKE_BINARIES) {
            [
                'linux-amd64',
                'linux-arm64',
                'darwin-amd64',
                'darwin-arm64',
                'windows-amd64'
            ].each { target -> sh "touch ${target}/git-remote-gosh_${version}" }
            return true
        }

        String PIPELINE_1_ID
        dir("${version}/git-remote-gosh") {
            String PIPELINE_1_STATUS = ''

            if (params.DRYRUN) {
                PIPELINE_1_ID = sh(
                    script: """
                        az pipelines build queue --definition-id 1 --branch ${COMMIT} --project gosh \
                            --variables versionNo=${versionPath} \
                            --variables VERSION=${version} \
                            --variables DRYRUN=true \
                            | jq -r .id
                    """,
                    returnStdout: true,
                ).trim()
            } else {
                PIPELINE_1_ID = sh(
                    script: """
                        az pipelines build queue --definition-id 1 --branch ${COMMIT} --project gosh \
                            --variables versionNo=${versionPath} \
                            --variables VERSION=${version} \
                            | jq -r .id
                    """,
                    returnStdout: true,
                ).trim()
            }

            timeout(time: 3, unit: 'HOURS') {
                while (PIPELINE_1_STATUS != 'completed') {
                    sleep time: 60, unit: 'SECONDS'
                    PIPELINE_1_STATUS = sh(
                        script: "az pipelines build show --project gosh --id ${PIPELINE_1_ID} | jq -r .status",
                        returnStdout: true,
                    ).trim()
                    println "$PIPELINE_1_STATUS"
                }
            }
        }

        retry(3) {
            allTargets.each { target ->
                sh "az pipelines runs artifact download --project gosh --artifact-name ${target} --run-id ${PIPELINE_1_ID} --path ${target}"
                sleep 2
            }
        }
    }
}

def archiveAzureArtifacts() {
    script {
        sh 'pwd'
        def nixTargets = [
            'linux-amd64',
            'linux-arm64',
            'darwin-amd64',
            'darwin-arm64',
        ]
        def allTargets = [
            'linux-amd64',
            'linux-arm64',
            'darwin-amd64',
            'darwin-arm64',
            'windows-amd64',
        ]
        sh 'rm -rf git-remote-gosh-*.tar.gz git-remote-gosh-*.exe'

        // dispatcher.ini
        sh "find . -name 'git-remote-gosh_v*' | tr -d ./ | tee dispatcher.ini"
        nixTargets.each { target -> sh "chmod +x ${target}/git*" }
        allTargets.each { target -> sh "cp dispatcher.ini ${target}/" }
        sh 'rm -rf dispatcher.ini'

        // log
        allTargets.each { target -> sh "ls -lA ${target}/" }

        // prepare archives
        nixTargets.each { target ->
            sh "tar -czvf git-remote-gosh-${target}.tar.gz -C ${target} \$(ls -A ${target})"
        }

        dir('windows-amd64') {
            sh 'zip -r git-remote-gosh-windows-amd64.zip ./* && cp git-remote-gosh-windows-amd64.zip ../'
        }

        sh 'ls -lA'
    }
}

// FUNCTIONAL TESTS & DEPLOYS

def getTestFiles(testsDir) {
    def files
    dir(testsDir) {
        files = sh(script: 'ls *.test.sh | grep "[0-9][0-9]\\+"', returnStdout: true).trim().split('\n')
    }
    return files
}

def deployVersion(version, files, basePort) {
    def containerStages = [:]

    for (int i = 0; i < files.size(); i++) {
        def port = basePort + i
        def index = i
        containerStages["Deploy ${version} ${i}"] = {
            stage("Deploy ${version} ${index}") {
                retry(3) {
                    deployStage(version, index, port)
                }
            }
        }
    }
    parallel containerStages
}

def deployStage(version, index, port) {
    echo "Checking if Docker container localnode-${port} is already running"
    def containerRunning = sh(returnStdout: true, script: "docker ps --filter name=localnode-${port} --format '{{.Names}}'").trim()

    if (!containerRunning) {
        echo "Starting Docker container on port ${port}"
        sh """
            set +e
            docker run -d --name localnode-${port} --network test.app.gosh.sh -p ${port}:80 -e USER_AGREEMENT=yes -v ${WORKSPACE}/.ci/blockchain.conf:/ton-node/blockchain.conf.json tonlabs/local-node:0.35.1
        """
    } else {
        echo "Docker container localnode-${port} is already running"
    }

    sh "cp -r ${version} ${version}_workspace_${index}"
    env.version = version
    dir("${WORKSPACE}/${version}_workspace_${index}/contracts/multisig") {
        sh "make generate-docker NETWORK=http://localnode:${port}"
        env.giverAddr = sh(returnStdout: true, script: 'cat Giver.addr').trim()
        sh """
            tonos-cli -u http://localnode:${port} call 0:ece57bcc6c530283becbbd8a3b24d3c5987cdddc3c8b7b33be6e4a6312490415 sendTransaction '{"dest": "${env.giverAddr}", "value": 50000000000000000, "bounce": false}' --abi GiverV2.abi.json --sign GiverV2.keys.json
        """
        sh 'sleep 10 && make deploy-docker EXTRA_DOCKER_ARGS="--network host --add-host localnode:127.0.0.1"'
    }
    dir("${WORKSPACE}/${version}_workspace_${index}/contracts/gosh") {
        sh 'sleep 10 && make prepare-docker && make deploy-docker EXTRA_DOCKER_ARGS="--network host --add-host localnode:127.0.0.1"'
    }
}

def runFunctionalTests(files, basePort, stagePrefix, version) {
    def containerStages = [:]

    for (int i = 0; i < files.size(); i++) {
        def script = files[i]
        def port = basePort + i
        def index = i
        containerStages["${stagePrefix} ${script}"] = {
            stage("${stagePrefix} ${script}") {
                runSingleFunctionalTest(script, index, port, version)
            }
        }
    }
    parallel containerStages
}

def runSingleFunctionalTest(script, index, port, version) {
    prepareHelperForTests()
    sh "cp -r tests tests_workspace_${index}"
    dir("${WORKSPACE}/tests_workspace_${index}") {
        sh """
            export PATH=/home/jenkins/.everdev/tonos-cli/:/home/jenkins/bin:$PATH
            export GOSH_REMOTE_WAIT_TIMEOUT=500
            ./set-vars.sh ${version}_workspace_${index} http://localnode:${port}
            ./${script}
        """
    }
}

def runUpgradeTests(files, basePort, from, to) {
    def containerStages = [:]

    for (int i = 0; i < files.size(); i++) {
        def script = files[i]
        def port = basePort + i
        def index = i
        containerStages["Upgr $from-$to ${script}"] = {
            stage("Upgr ${script}") {
                runSingleUpgradeTest(script, index, port, from, to)
            }
        }
    }
    parallel containerStages
}

def runSingleUpgradeTest(script, index, port, from, to) {
    prepareHelperForTests()
    sh "cp -r tests tests_workspace_${index}"
    dir("${WORKSPACE}/tests_workspace_${index}") {
        sh """
            export PATH=/home/jenkins/.everdev/tonos-cli/:/home/jenkins/bin:$PATH
            export GOSH_REMOTE_WAIT_TIMEOUT=500
            ./set-vars.sh ${from}_workspace_${index} http://localnode:${port}
            ./upgrade_tests/set_up.sh ${from}_workspace_${index} ${to}_workspace_${index}
            ./upgrade_tests/${script}
        """
    }
}

def prepareHelperForTests() {
    dir("${WORKSPACE}/tests") {
        // TODO: remove `chmod`s because we should emulate user's machine
        sh """
            #!/bin/bash
            set -e
            set -x
            cd ../tests
            mkdir -p /home/jenkins/bin

            # dispatcher
            cp -r /tmp/${JOB_NAME}/linux-amd64/git-remote-gosh /home/jenkins/bin/git-remote-gosh && chmod +x /home/jenkins/bin/git-remote-gosh

            # remote
            cd /tmp/${JOB_NAME}/linux-amd64/
            # REMOTE_VERSION=\$(find . -name "git-remote-gosh_*" | tr -d "./")
            cd -
            cp -r /tmp/${JOB_NAME}/linux-amd64/git-remote-gosh_* /home/jenkins/bin/ && chmod +x /home/jenkins/bin/git-remote-gosh_*
            mkdir -p /home/jenkins/.gosh/
            # echo \$REMOTE_VERSION > /home/jenkins/.gosh/dispatcher.ini
            cd /home/jenkins/bin/
            ls git-remote-gosh_* -1 > /home/jenkins/.gosh/dispatcher.ini
        """
    }
}

// WEB

def deployWeb() {
    script {
        env.BUCKET_NAME = 'app-' + "${COMMIT}_${APP_VERSION}".replaceAll('[^a-zA-Z0-9 ]+', '-')
        sh """
            sed -i '/REACT_APP_GOSH_ROOTADDR =/s/\$/${REACT_APP_GOSH_ROOTADDR}/' web/.env.ci
            sed -i '/REACT_APP_GOSH =/s/\$/{"1.0.0": "${REACT_APP_GOSH}"}/' web/.env.ci
            cat web/.env.ci
        """
        dir('web') {
            sh 'make build ENV=ci REACT_APP_ISDOCKEREXT=false'
            def status = sh(script: "aws s3api head-bucket --bucket ${BUCKET_NAME}", returnStatus: true)
            if (status == 0) {
                echo 'Bucket already exists. Just syncing.'
                sh "aws s3 sync build/ s3://${BUCKET_NAME}"
            } else {
                sh """
                    aws s3api create-bucket --bucket ${BUCKET_NAME} --region eu-west-2 --create-bucket-configuration LocationConstraint=eu-west-2
                    aws s3 website s3://${BUCKET_NAME} --index-document index.html --error-document index.html
                    aws s3api put-public-access-block --bucket "${BUCKET_NAME}" --public-access-block-configuration "BlockPublicPolicy=false"
                    sed 's/BUCKET_NAME/${BUCKET_NAME}/g' ../.ci/s3/policy.json.template > policy.json
                    aws s3api put-bucket-policy --bucket ${BUCKET_NAME} --policy file://policy.json
                    aws s3 sync build/ s3://${BUCKET_NAME}
                    sed "s/BUCKET_NAME/\$BUCKET_NAME/g" ../.ci/nginx/proxy.s3.conf.template >> /opt/nginx/s3-proxy.conf
                    docker restart nginx-test-app-gosh-sh
                """
            }
        }
        timeout(15) {
            waitUntil {
                def r = sh script: "sleep 20 && curl -s --retry-connrefused --retry 100 --retry-delay 5 https://${BUCKET_NAME}.gosh.sh > /dev/null", returnStatus: true
                return r == 0
            }
        }
    }
}

def testWeb() {
    script {
        dir('monitoring/gosh-mon') {
            sh 'cp config/credentials.yml.template config/credentials.yml'
            sh 'docker build --no-cache -t gosh-mon .'
            def tests = webTestsList()
            for (int i = 0; i < tests.length; i++) {
                stage("Test ${tests[i]}") {
                    sh """
                        mkdir -p test-errors/${tests[i].trim()}
                        docker run --rm \
                            -e GM_MODE='${tests[i].trim()}' \
                            -e RUN_NOW=1 \
                            -e CONFIG_SEED="\$(cat ../../tests_workspace_0/user.seed)" \
                            -e CONFIG_APPURL=https://${BUCKET_NAME}.gosh.sh/ \
                            -e CONFIG_REDIS_HOST="" \
                            -e CONFIG_USERNAME=user1 \
                            -v \$(pwd)/config:/home/node/app/config:ro \
                            -v \$(pwd)/test-errors:/home/node/app/errors \
                            --network host --add-host localnode:127.0.0.1 \
                            gosh-mon
                    """
                }
            }
        }
    }
}

// RELEASE

def prereleaseBinaries() {
    script {
        if (!params.DRYRUN) {
            dir('.ci/scripts') {
                withCredentials([string(credentialsId: 'github-gosh-release', variable: 'TOKEN')]) {
                    sh './create-github-release.sh $TOKEN ${APP_VERSION} ${COMMIT}'
                    /// LINUX
                    sh './github-upload-assets.sh $TOKEN ${APP_VERSION} /tmp/${JOB_NAME}*/git-remote-gosh-linux-amd64.tar.gz application/gzip'
                    sh './github-upload-assets.sh $TOKEN ${APP_VERSION} /tmp/${JOB_NAME}*/git-remote-gosh-linux-arm64.tar.gz application/gzip'
                    /// MAC OS
                    sh './github-upload-assets.sh $TOKEN ${APP_VERSION} /tmp/${JOB_NAME}*/git-remote-gosh-darwin-amd64.tar.gz application/gzip'
                    sh './github-upload-assets.sh $TOKEN ${APP_VERSION} /tmp/${JOB_NAME}*/git-remote-gosh-darwin-arm64.tar.gz application/gzip'
                    /// WINDOWS
                    sh './github-upload-assets.sh $TOKEN ${APP_VERSION} /tmp/${JOB_NAME}*/git-remote-gosh-windows-amd64.zip application/zip'

                //sh './package-deb.sh /tmp/${JOB_NAME}'
                //sh './github-upload-assets.sh $TOKEN ${APP_VERSION} ./git-remote-gosh-windows_amd64.deb application/octet-stream'
                //sh './github-upload-assets.sh $TOKEN ${APP_VERSION} ./git-remote-gosh-windows_arm64.deb application/octet-stream'
                }
            }
        }
    }
}

def prereleaseDockerExtension() {
    script {
        if (!params.DRYRUN && params.DOCKER_EXTENSION) {
            dir('docker-extension') {
                withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'teamgosh-dockerhub', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
                    sh 'docker login -u $USERNAME -p $PASSWORD'
                }
                sh "make push IMAGE=teamgosh/docker-extension TAG=rc-${APP_VERSION} PLATFORM=linux/amd64,linux/arm64"
            }
        }
    }
}

def webTestsList() {
    return 'app-setup,seed-read,app-small-write,app-small-read,app-large-write,app-large-read'.split(',')
}

        //////////////////////////////////////////////////////////////////////////////////////////////
        ////////////DEPRECATED/////////////////////////////////////////
        /*stage('Build: Docker Extension') {
            agent {
                docker {
                    image 'jenkins-docker-agent:1'
                    args '-v /var/run/docker.sock:/var/run/docker.sock -v /opt:/opt --group-add docker'
                }
            }
            steps {
                script {
                    dir('docker-extension') {
                        sh "make push IMAGE=localhost:5000/teamgosh/docker-extension TAG=${APP_VERSION} PLATFORM=linux/amd64,linux/arm64 GOSH_GIT_IMAGE=localhost:5000/teamgosh/git:${APP_VERSION}"
                    }
                }
            }
        }*/

                /*stage("Prerelease: Git Helper Snap"){
            agent {
                node {
                    label 'jenkins-main'
                }
            }
            steps {
                script {
                    if (!params.ONLYWEB && !params.DRYRUN) {
                        dir('v2_x/git-remote-gosh') {
                        sh """
                            cp /var/jenkins_home/workspace/gosh-prepare-rc/git-remote-gosh/git-remote-gosh-amd64 snap/git-remote-gosh
                            sed -i 's/VERSION_PLACEHOLDER/${APP_VERSION}/g' snap/snapcraft.yaml
                            chmod +x snap/git-remote-gosh
                            cd snap
                            tar -czvf git-remote-gosh.tar.gz git-remote-gosh
                            snapcraft clean --use-lxd
                            snapcraft --use-lxd
                            snapcraft upload git-remote-gosh_${APP_VERSION}_amd64.snap --release=candidate
                        """
                        }
                    }
                }
            }
        }*/
